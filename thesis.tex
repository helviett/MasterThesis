\documentclass{fefu_thesis/cls/fefu}

\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}

\newenvironment{algo}[1][]
  {\begin{algorithm}[#1]
     \selectlanguage{english}
     \floatname{algorithm}{Алгоритм}
  }
  {\end{algorithm}}

\algdef{SE}[DOWHILE]{Do}{DoWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%

\newcommand*\gsegment[1]{\overline{#1}}
\newcommand*\gline[1]{\overleftrightarrow{#1}}

\author{Терехов Д.Е.}
\setschool{ШКОЛА ЕСТЕСТВЕННЫХ НАУК ДВФУ}
\setgroup{Б8403а}

\begin{document}
    \tableofcontents
    \pagebreak
    \begin{abstract}
        В данной работе представлены два эффективных алгоритма: генерация текстурного меша с последующим упрощением и упаковка полигональных текстур в атлас. Оба алгоритма работают с полигонами следующих типов: невыпуклые, полигоны с дырами, полигоны, состоящие из нескольких контуров.

        \textit{Ключевые слова: генерация меша, упрощение полигонов, упаковка в контейнеры.}
    \end{abstract}
    \pagebreak
    {\centering\section*{Введение}}
    Целью работы является решение задач упрощения полигонов и упаковки, которые играют важную роль в таких прикладных областях, как компьютерная графика, GIS системы, промышленность и т.д. Решение этой задачи также опирается на прикладную область: компьютерную графику, а именно автоматическую генерацию текстурного меша с последующей упаковкой полигональных текстур в текстурные атласы.

    Упаковка в текстурные атласы это один из этапов подготовки ассетов-текстур для оптимального использования: маленькие текстуры становятся частью большого изображения -- текстурного атласа. Это позволяет минимизировать затраты по памяти, а также уменьшить количество вызовов на отрисовку. Полигонизация текстур позволяет уменьшить количество вызовов фрагментного шейдера, путем минимизации площади пустых пикселей, входящих в меш. Также это позволяет упаковать больше текстур в атлас, т.к. в полигональном виде они занимают меньшую площадь.

    К сожалению, нет открытых программных пакетов или статей, которые решают поставленные задачи. Все программные пакеты являются проприетарными, а известные статьи решают данные задачи в очень упрощенном виде. Это и послужило мотивацией для проведение исследований и создания новых алгоритмов.

    В разделе "Раз" более подробно описывается проблема, подлежащая решению, дается обзор теоретических положений и практических подходов к решению поставленных задач.

    В разделе "Два" предлагается теоретическое решение, формируются критерии оценки эффективности алгоритмов, обоснование их корректности. Также приводится описание вспомогательных и основных алгоритмов.

    В разделе "Три" описывается применение результатов исследования в реальном проекте -- игровом движке с открытым исходным кодом <<Citrus>>.

    \section*{Глоссарий}
    \section{Задачи упрощения полигонов и упаковки в контейнеры}

    Целью работы является решение задач упрощения полигонов и упаковки, которые играют важную роль в таких прикладных областях, как компьютерная графика, GIS системы, промышленность и т.д. Решение этой задачи также опирается на прикладную область: компьютерную графику, а именно автоматическую генерацию текстурного меша с последующей упаковкой полигональных текстур в текстурные атласы.

    \subsection{Генерация текстурного меша}

    Полигональный меш (полигональная сетка) -- это совокупность вершин, рёбер и граней, которые определяют форму многогранного объекта в трёхмерной компьютерной графике и объёмном моделировании. В двумерной компьютерной графике меши используются для вершинной и скелетной анимации.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.5]{images/spine_mesh.png}
        \caption{2D меш}
    \end{figure}

    Для того, чтобы отрисовать изображение на экране, необходимо пройти через графический конвейер. Обязательными и важнейшими этапами графического конвейера являются исполнение вершинного и фрагментного шейдеров, которые запускаются для каждой вершины и каждого фрагмента (пикселя) соответственно. После вызова фрагментного шейдера полученный цвет фрагмента смешивается с цветом фрагмента в буфере кадра. Многие изображения содержат огромное количество прозрачных пикселей. Вызов фрагментного шейдера для таких пикселей часто является бессмысленным, так как прозрачных пиксель при смешивании никак не повлияет на цвет на экране.
    Эти размышления приводят к одному из способов оптимизации: создание полигонального меша для изображения таким образом, чтобы минимизировать число вершин и пустых пикселей, занимаемых площадью меша.
    %МБ ВСТАВИТЬ КАРТИНКУ ГРАФИЧЕСКОГО ПАЙПЛАЙНА%

    \begin{figure}[H]
        \centering
        \includegraphics{images/Thunder_approx.png}
        \caption{Полигональный меш с 10 вершинами}
    \end{figure}

    Для GIS систем разработали множество алгоритмов упрощения кривой: алгоритм Ramer–Douglas–Peucker\cite{Ramer}\cite{DouglasPeucker}, алгоритм радиального расстояния\cite{PolylineSimplification}, алгоритм Visvalingam–Whyatt\cite{VisvalingamWhyatt}, упрощение Opheim\cite{Opheim} и Lang\cite{Lang}, алгоритм Zhao–Saalfeld\cite{ZhaoSaalfeld}, алгоритм Reumann-Witkam\cite{ReumannWitkam}.

    Однако в данной работе задача упрощения полигонов применяется в контексте текстурного меша. Ключевыми отличиями данной прикладной задачи от общей является минимизация не только количества вершин, но и площади прозрачных пикселей (или добавочной площади), а также ограничение, которое не позволяет нарушать границы исходных полигонов (контур изображения). Описанные выше алгоритмы можно адаптировать, чтобы они соответствовали ограничению. К сожалению, данные алгоритмы совсем не рассчитаны на минимизацию добавочной площади, а также часто приходят в тупиковую ситуацию, когда все ещё требует уменьшить количество вершин, но возможных трансформаций не существует. Решение данных проблем привело к созданию алгоритма упрощения множества простых полигонов с дырками.

    \subsection{Упаковка текстур в атласы}

    Упаковка в текстурные атласы это один из этапов подготовки ассетов-текстур для оптимального использования: маленькие текстуры становятся частью большого изображения -- текстурного атласа. Под­текстуры отображаются на объект, используя UV ­преобразование, при этом координаты в атласе задают, какую часть изображения нужно использовать. В приложениях нередко используется множество маленьких текстур, причём переключение с одной текстуры на другую является относительно медленным процессом. Поэтому в подобных ситуациях целесообразно применение одного большого изображения вместо множества маленьких. Также текстурные атласы помогают сэкономить память при помощи полигональной упаковки и\textbackslash или алгоритмов сжатия.

    Задача упаковки в контейнеры -- NP-трудная комбинаторная задача. Задача заключается в упаковке объектов предопределённой формы в конечное число контейнеров предопределённой формы таким способом, чтобы число использованных контейнеров было наименьшим или количество или объём объектов (которые упаковывают) были наибольшими. В данной работе предлагается решение 2D irregular bin packing problem, т.е. упаковка полигональных объектов в прямоугольные контейнеры.

    Для упаковки прямоугольных объектов существует множество эвристических алгоритмов\cite{ThousandWayToPackBin}, которые хорошо показывают себя на практике. В области упаковки полигонов существуют различные подходы.

    No-fit polygon\cite{NofitPolygon}\cite{NofitPolygon2} -- это конструкция, которая определяет все положения, которые могут принимать 2 произвольных многоугольника относительно друг друга так, чтобы они соприкасались, но не перекрывались. Часто методы на основе no-fit polygon используют для решения задачи раскроя на производстве, где форма вырезаемых объектов несложная и заранее известна.

    Swarm intelligence (роевой интеллект) -- метод оптимизации, который описывает коллективное поведение децентрализованной самоорганизующейся системы: колонии светлячков\cite{FireFly}, муравьев\cite{AntColony}, пчел\cite{PlayrixArticle}, particle swarm optimization\cite{PSO}.

    Генетический алгоритм\cite{JAKOBS1996165} -- это эвристический алгоритм поиска, используемый для решения задач оптимизации и моделирования путём случайного подбора, комбинирования и вариации искомых параметров с использованием механизмов, аналогичных естественному отбору в природе.

    К сожалению, результаты прочитанных статей не удовлетворяют нужды упаковки текстур в атласы, поэтому данная работа предлагает собственную реализацию Memetic algorithm -- расширение генетического алгоритма, которое использует локальный поиск для уменьшения вероятности преждевременной сходимости. Разработанный алгоритм способен упаковывать изображения, на которых находятся множество разрозненных объектов с дырами.

    \section{Алгоритмы, структуры данных и математические методы}
    \subsection{Пайплайн полигональной упаковки}
    \begin{itemize}
        \item Трассировка контура изображений;
        \item Аппроксимация полученных контуров;
        \item Упаковка полигональных изображений в текстурные атласы.
    \end{itemize}
    \subsection{Трассировка контура}
    Алгоритмы выделения контура можно разделить на 3 типа: обход попиксельно, обход повершинно, run-data.
    \subsubsection{Обход попиксельно}
    Метод выделения контура обходом попиксельно начинает с какого-либо стартового пикселя и пиксель за пикселем обходит контур изображения предопределенным образом, а затем сохраняет их координаты в памяти в соответствии с порядком трассировки. Наиболее известные алгоритмы обхода контура попиксельно: Moore-neighbor tracing\cite{MoorNeighbor}, radial sweep\cite{RadialSweep} и алгоритм Theo Pavlidis\cite{TheoPavlidis}.
    \subsubsection{Обход повершинно}
    Метод выделения контура обходом повершинно отличается от обхода попиксельно лишь тем, что обход осуществляется по границам пикселя.
    \subsubsection{Run-data}
    Run-data методы выделения контура проходят по изображению сканирующей линией оставляя определенные метки на встреченном граничном пикселе. Далее по расставленным меткам восстанавливается контур изображения. Примеры методов этой группы: run-type direction code\cite{Miyatake1997}, методы, основанные на PXY таблице\cite{Shoji}. Отличительной особенностью run-data методов является возможность выделения внешних и внутренних контуров, сохраняя иерархию. Так же способ обхода изображения в некоторых алгоритмах позволяет не держать в памяти изображение целиком.

    Было решено выбрать алгоритм именно из этой группы методов, так как необходимо выделять дырки на объектах. За основу был взят алгоритм Suzuki Satoshi \cite{SuzukiAlgorithm}, использующийся в библиотеке OpenCV. Алгоритм способен построить иерархию контуров и типизировать их на границы и дыры.

    \begin{figure}[H]
        \centering
        \begin{subfigure}[t]{.49\linewidth}
            \includegraphics[scale=0.4]{images/SuzukiExample_upscaled.png}
            \caption{Изображение}
        \end{subfigure}
        \begin{subfigure}[t]{.49\linewidth}
            \includegraphics[scale=0.4]{images/SuzukiExample_contours_upscaled.png}
            \caption{Контуры изображения}
        \end{subfigure}
        \begin{subfigure}[t]{.99\linewidth}
            \centering
            \includegraphics[scale=0.7]{images/SuzukiExample_hierarchy.png}
            \caption{Иерархия контуров}
        \end{subfigure}
        \caption{Пример работы алгоритма Suzuki Satoshi}
    \end{figure}

    Алгоритм оперирует с дискретными координатами пикселей, а в компьютерной графике UV координаты это непрерывные вещественные числа. Такое представление контура создает некоторые проблемы.

    Во-первых, может получится контур с самопересечениями, которые нетривиально разрешить. На \ref{SelfIntersectingContours} изображены примеры контуров с самопересечением. Красным обозначены вершины, которые алгоритм посещает дважды.
    \begin{figure}[H]
        \centering
        \begin{subfigure}[t]{.49\linewidth}
            \centering
            \includegraphics[scale=0.2]{images/SelfIntersectingContour1.png}
            \caption{Изображение}
        \end{subfigure}
        \begin{subfigure}[t]{.49\linewidth}
            \centering
            \includegraphics[scale=0.4]{images/SelfIntersectingContour2.png}
            \caption{Контуры изображения}
        \end{subfigure}
        \caption{Примеры контуров с самопересечением}
        \label{SelfIntersectingContours}
    \end{figure}

    Во-вторых, некоторые пиксели при отрисовке будут обрезаны, т.к. дискретные координаты пикселя в прямой интерпретации в качестве UV координат будут являются координатами левого верхнего угла пикселя. В таком случае, нижние и правые пиксели просто не будут учтены при отрисовке.

    \begin{figure}[H]
        \centering
        \begin{subfigure}[t]{.33\linewidth}
            \centering
            \includegraphics[scale=0.2]{images/SuzukiExample2.png}
            \caption{Изображение}
        \end{subfigure}
        \begin{subfigure}[t]{.33\linewidth}
            \centering
            \includegraphics[scale=0.2]{images/SuzukiExample2_uvs.png}
            \caption{Контуры изображения + UV координаты}
        \end{subfigure}
        \begin{subfigure}[t]{.32\linewidth}
            \centering
            \includegraphics[scale=0.2]{images/SuzukiExample2_wanted_uvs.png}
            \caption{Контур изображения и желаемые UV координаты}
        \end{subfigure}
        \caption{Проблема неправильных UV координат}
    \end{figure}

    Для решения данных проблем был разработан алгоритм, который превращает попиксельный контур в повершинный.
    \begin{algo}[H]
        \setstretch{1}
        \caption{Pixel contour to vertex contour}
        \begin{algorithmic}[1]
            \Procedure{ToVertexContour}{$contour, type$}
                \State $vertices$ $=$ $[]$
                \State $prevTexel$ $=$ $contour$$[0]$
                \If{$type == Hole$}
                    \State $verticies.Add(position)$
                \EndIf
                \State $position$ $=$ $type$ $==$ $Outer$ $?$
                \State $prevTexel$ $:$
                \State $NextCWVertex(prevTexel, NextCWVertex(prevTexel, prevTexel))$
                \For{$i = 1$ \textbf{to} $contour.Size$}
                    \State $currentTexel = contour[i]$
                    \State $position = TracePixel(prevTexel, currentTexel, position, vertices)$
                    \State $prevTexel = currentTexel$
                \EndFor
                \State $TracePixel(prevTexel, contour[0], position, vertices)$
                \State \textbf{return} $vertices$
            \EndProcedure
            \Procedure{TracePixel}{$prevTexel, texel, position, vertices$}
                \Do
                    \State $position = NextCWVertex(prevTexel, position)$
                    \State $vertices.Add(position)$
                \DoWhile { $!IsVertexOf(texel, position)$ }
                \State \textbf{return} $position$
            \EndProcedure
        \end{algorithmic}
    \end{algo}

    Функции NextCCWVertex(texel, vertex) и NextCWVertex(texel, vertex) возвращают следующую вершину текселя против и по часовой соответственно. IsVertexOf(texel, vertex) возвращает true, если вершина принадлежит текселю.

    Для того, чтобы снизить количество вершин перед следующим этапом обработки изображения, контуры подвергаются первичной аппроксимации. Самым очевидным способом аппроксимации контура является удаление вершин лежащих на одной прямой. Также существуют алгоритмы упрощения цифровых кривых. В данной работе был реализован алгоритм Teh-Chin\cite{TehChin} c $L1$ и $k\cos$ метриками.

    \subsection{Аппроксимация полигонов}
    Аппроксимация полигонов для текстурных мешей отличается от аппроксимации полигонов, например, в GIS системах: запрещено нарушать искомые границы, а так же необходимо минимизировать не только количество вершин, но и добавочную площадь. Мета-алгоритм можно описать следующим образом:

    \begin{algo}[H]
        \setstretch{1}
        \caption{Meta-algorithm for a set of polygons approximation}
        \begin{algorithmic}[1]
            \Procedure{ApproximatePolygons}{$polygons, hierarchy, frameRect$}
                \State $minExtractor, topology, frame = $
                \State $Initialize(polygons, hierarchy, frameRect)$
                \While {Termination Condition is not achieved}
                    \If {$!TryApproximate(\cdots)$ and $!TryMerge(\cdots)$}
                    \State \textbf{break}
                    \EndIf
                \EndWhile
                \State \textbf{return} $RetrieveImage(\cdots)$
            \EndProcedure
        \end{algorithmic}
    \end{algo}

    На стадии инициализации создаются две модели множества полигонов. Первая модель это дерево полигонов, где каждый узел дерева это полигон $P_i$, представленный двусвязным зацикленным списком вершин $P_i = \left(v_j\right)_{j=0}^{n - 1}$, $v_{j \pm m}$ подразумевает $v_{j \pm m \pmod n}$. Корнем дерева является ограничивающая рамка ($frame$). Вторая модель ($topology$) это триангуляция Делоне с ограничениями. В реализации алгоритма использовался пакет, разработанный в рамках бакалаврской выпускной квалификационной работы \cite{Delaunay}. Данный пакет подвергся доработке и оптимизациям СМ ПОДРАЗДЕЛ КАКОЙ-ТО. Триангуляция Делоне это мощнейший инструмент для проверки преобразований над полигонами, а также вычисления полигона видимости. Подробнее в РАЗДЕЛЕ НОМЕР КАКОЙ-ТО. Также на стадии инициализации происходит подсчет минимальной возможной трансформации для каждой вершины. "Стоимость" трансформации измеряется в добавочной площади. Для быстрого поиска минимальной трансформации (т.е. трансформации с минимальной стоимостью) используется сбалансированное дерево поиска ($minExtractor$).

    Далее выполняются преобразования или мерджатся полигоны, пока не условие выхода не будет достигнуто. Процедура $RetrieveImage$ возвращает объект типа $Image$. $Image$ содержит в себе все вершины и индексных массив (массив троек индексов вершин), а также массив объектов типа $ImageObject$. Объектом картинки называется граничный контур со всеми принадлежащими ему дырами. $ImageObject$ содержит в себе индексы вершин для контура и всех дыр, а также индексы троек индексов, ему принадлежащих. Данные структуры данных в дальнейшем используются для упаковки.

    \subsubsection{Преобразования над вершинами}
    Стоимостью преобразования является добавляемая площадь площадь, которая представляет из себя один или два треугольника. Возможность преобразования проверяется путем вставки в триангуляцию структурных ребер и проверки на существование определенного треугольника. Данная проверка необходима для того, чтобы избежать случаев, когда какая-то другая граница попадает в добавочную площадь.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/triangle_existance_check.png}
        \caption{Соседняя граница попадает в добавочную площадь}
    \end{figure}

    \paragraph{Удаление вершин, лежащий на одной прямой}
    Очевидно, данная трансформация имеет нулевую стоимость и проста в реализации.
    \paragraph{Удаление вогнутого/выпуклого угла}
    Если вершина $v_i$ принадлежит границе или дыре и образует вогнутый или выпуклый угол соответственно, то возможно провести отрезок $\gsegment{v_{i - 1}v_{i + 1}}$ и удалить вершину $v_i$. Также из теоремы о двух ушах следует, что любой последовательностью  таких преобразований можно сократить дыру до треугольника. Теорема о двух ушах гласит, что в каждом просто полигоне с более чем 3 вершинами есть хотя бы 2 уха. Ухом называется вершина, соседние вершины которой можно соединить отрезком, который будет полностью лежать внутри полигона.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/earcut.png}
        \caption{Удаление вогнутого угла}
    \end{figure}
    \paragraph{Пересечение сторон}
    Если $v_i$ образует выпуклый угол, то может существовать возможность заменить вершину $v_i$ и $v_{i + 1}$ пересечением прямых $\gline{v_{i - 1}v_i}$ и $\gline{v_{i + 1}v_{i + 2}}$. Для проверки возможности такого преобразования необходимо предварительно проверить знак параметра при пересечении прямых, используя векторное параметрическое уравнение ($\vec{r} = \vec{r_0} + t \cdot \vec{u}$).

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/bendneighbor2.png}
        \caption{Пересечение сторон}
    \end{figure}

    \paragraph{Выгибание соседней вершины}
    Данное преобразование является оптимизированной версией удаления вогнутого угла. Если линия, образованная предыдущей и пред предыдущей вершинами, пересекает сторону, образованную текущей и следующей вершинами, то существует возможность заменить предыдущую и текущую вершины пересечением линии и стороны. Аналогично для четверки следующая, последующая, текущая и предыдущая вершин.

    Данное преобразование является оптимизированной версией удаления вогнутого угла. Если $\gline{v_{i - 2}v_{i - 1}}$ пересекает $\gsegment{v_iv_{i + 1}}$, то можно не отрезать весь угол, а заменить $v_{i - 1}$ и $v_{i}$ пересечением. Аналогично работает для $\gline{v_{i + 2}v_{i + 1}}$ и $\gsegment{v_iv_{i - 1}}$.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/bendneighbor.png}
        \caption{Выгибание соседней вершины}
    \end{figure}

    \paragraph{Выгибание двух соседних вершин}
    Пусть $v_{i - 1}$, $v_{i}$ и $v_{i + 1}$ являются вершинами выпуклых углов, тогда можно попробовать заменить все 3 вершины пересечением $\gline{v_{i - 2}v_{i - 1}}$ и $\gline{v_{i + 2}v_{i + 1}}$ с вертикальной или горизонтальной прямой, проходящей через $v_i$.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/bendoutboth.png}
        \caption{Выгибание двух соседних вершин к вертикальной прямой}
    \end{figure}
    \paragraph{Удаление треугольной дыры}
    Если дыра упростилась до треугольника и внутри нет граничных полигонов, то единственная возможная трансформация для этих вершин -- удаление всей треугольной дыры. Это также влечет за собой удаление полигона из дерева полигонов.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1]{images/remove_triangular_hole.png}
        \caption{Удаление треугольной дыры}
    \end{figure}

    \subsubsection{Мердж полигонов}
    Рассказ про Triangular Expansion, алгоритм Joe and Simpson и алгоритм Asano.
    \begin{figure}[H]
        \centering
        \begin{subfigure}[t]{\linewidth}
            \centering
            \includegraphics[scale=1]{images/polygonmerge.png}
            \caption{Мердж границы с дырой}
        \end{subfigure}
        \begin{subfigure}[t]{\linewidth}
            \centering
            \includegraphics[scale=1]{images/polygonmerge2.png}
            \caption{Мердж границы с границей}
        \end{subfigure}
    \end{figure}

    \subsubsection{Применение преобразований}
    На каждой итерации цикла применяется аппроксимирующее преобразование с минимальной стоимостью. После применения преобразования пересчитываются преобразования соседних вершин.
    Аппроксимация соседних контуров или объемлющей дыры могут повлияет на валидность посчитанного преобразования, поэтому при неудачной попытке преобразование для вершины пересчитывается и вершина кладется обратно в $minExtractor$. Такой ленивый пересчет позволяет избежать огромных временных затрат, так как любая трансформация может в худшем случае повлиять на трансформацию $O\left(n\right)$ вершин. Однако на практике такое встречается редко.

    \subsubsection{Вычислительная устойчивость}
    Вычислительная устойчивость алгоритма достигается использованием вычислительно устойчивых геометрических предикатов, разработанных Jonathan Shewchuk\cite{shewchuk97a}. Данные предикаты также используются для построения Делоне с ограничениями.
    \subsubsection{Меш}
    В дальнейшем для упаковки и отрисовки в атлас понадобится меш всех объектов на изображении. Так как для аппроксимации создается триангуляция Делоне, то достаточно выбрать из неё нужные треугольники. Для этого достаточно запустить обход в глубину триангуляции. Основой триангуляции является структура данных Halfedge \cite{Halfedge}, представляющая собой ориентированное ребро с указателем на следующее и соседнее (ориентированное в обратном направлении) ребро. Каждое структурное (constrained) ребро триангуляции является ребром одного из полигонов. Значит, при переходе через такое ребро мы входим или выходим в/из площади объекта на картинке.

    \begin{algo}[H]
        \setstretch{1}
        \caption{Retrieve image mesh}
        \begin{algorithmic}[1]
            \State $used \gets \emptyset$
            \State $faceList \gets []$
            \State $polygonToFaceIndecies, sideToPolygon \gets Precalculate()$
            \Procedure{RetrieveMesh}{$edge, faceIndecies, faceList$}
                \If{$faceIndecies \neq null$} \Comment{Means inside a polygon}
                    \State $faceIndecies.Add(faceList.Count)$
                    \State $faceList.Add(edge.ToFace())$
                    \State $current \gets edge.Next$
                    \While{$current \neq edge$}
                        \If{$current.Twin \neq null \; \textbf{and} \; used \cap current != \emptyset$ }
                            \State $used \gets used \cup current$
                            \State $twin \gets current.Twin$
                            \State $fis \gets faceIndecies$
                            \If{$twin.IsConstrained$}
                                \State $polygon \gets sideToPolygon[edge]$ \Comment{returns polygon or null}
                                \State $fis \gets polygonToFaceIndecies[polygon]$
                            \EndIf
                            \State $RetrieveMesh(twin, fis, faceList)$
                        \EndIf
                    \EndWhile
                \EndIf
                \State $current \gets current.Next$
            \EndProcedure
        \end{algorithmic}
    \end{algo}

    \subsubsection{Доработка триангуляции Делоне}
    \cite{DelaunayRemove}\cite{LinearDelaunay}
    \newpage
    \bibliographystyle{ugost2008ls}
    \bibliography{references}
\end{document}
